// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Flags from "../lib/Flags.res.mjs";
import * as Server from "../lib/Server.res.mjs";
import * as Helpers from "../lib/Helpers.res.mjs";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";

var weakenScript = "/scripts/exec/WeakenOnce.res.js";

var growScript = "/scripts/exec/GrowOnce.res.js";

var hackScript = "/scripts/exec/HackOnce.res.js";

var schema = {
  includePurchasedServers: false,
  includeHome: false,
  help: false
};

var coresNum = [];

var servers = new Map();

var targets = new Map();

var scripts = new Map();

var todoTasks = [];

function actionToString(action) {
  switch (action) {
    case "Weaken" :
        return "weaken";
    case "Grow" :
        return "grow";
    case "Hack" :
        return "hack";
    
  }
}

function clearServers() {
  coresNum.splice(0, coresNum.length);
  servers.clear();
}

function updateServers(info) {
  if (!(info.hasAdminRights && info.maxRam > 0.0)) {
    return ;
  }
  if (!coresNum.some(function (cores) {
          return cores === info.cpuCores;
        })) {
    coresNum.push(info.cpuCores);
  }
  var serverInfo_host = info.hostname;
  var serverInfo_cores = info.cpuCores;
  var serverInfo_maxRam = info.maxRam;
  var serverInfo_usedRam = info.ramUsed;
  var serverInfo_availableRam = info.maxRam - info.ramUsed;
  var serverInfo = {
    host: serverInfo_host,
    cores: serverInfo_cores,
    maxRam: serverInfo_maxRam,
    usedRam: serverInfo_usedRam,
    availableRam: serverInfo_availableRam
  };
  var array = servers.get(info.cpuCores);
  if (array !== undefined) {
    array.push(serverInfo);
  } else {
    servers.set(info.cpuCores, [serverInfo]);
  }
}

function sortServers() {
  coresNum.sort(function (a, b) {
        if (a < b) {
          return 1;
        } else if (a > b) {
          return -1;
        } else {
          return 0;
        }
      });
  servers.forEach(function (serverList, cores) {
        serverList.sort(function (a, b) {
              if (a.availableRam < b.availableRam) {
                return 1;
              } else if (a.availableRam > b.availableRam) {
                return -1;
              } else {
                return 0;
              }
            });
        servers.set(cores, serverList);
      });
}

function updateTargets(ns, info) {
  var match = info.requiredHackingSkill;
  var match$1 = info.minDifficulty;
  var match$2 = info.hackDifficulty;
  var match$3 = info.moneyMax;
  var match$4 = info.moneyAvailable;
  if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined && match$4 !== undefined && info.hasAdminRights && (ns.getHackingLevel() / 2 | 0) >= match && match$3 > 0.0) {
    if (!targets.has(info.hostname) && !Array.from(scripts.values()).some(function (t) {
            return t.target === info.hostname;
          }) && !todoTasks.some(function (t) {
            return t.target === info.hostname;
          })) {
      todoTasks.push({
            action: "Weaken",
            target: info.hostname
          });
    }
    targets.set(info.hostname, {
          host: info.hostname,
          minSecurity: match$1,
          security: match$2,
          maxMoney: match$3,
          money: match$4
        });
    return ;
  }
  
}

function updateTasks(ns) {
  var running = new Set();
  var deleted = new Set();
  scripts.forEach(function (script, pid) {
        if (ns.isRunning(pid)) {
          running.add(script.target);
        } else {
          scripts.delete(pid);
          deleted.add(script.target);
        }
      });
  deleted.forEach(function (target) {
        if (running.has(target)) {
          return ;
        }
        var info = targets.get(target);
        if (info !== undefined) {
          if (info.security > info.minSecurity) {
            todoTasks.push({
                  action: "Weaken",
                  target: target
                });
          } else if (info.money < info.maxMoney) {
            todoTasks.push({
                  action: "Grow",
                  target: target
                });
          } else {
            todoTasks.push({
                  action: "Hack",
                  target: target
                });
          }
        } else {
          ns.print("ERROR: no target " + target + " in targets");
        }
      });
}

function sortTodoTasksExn() {
  todoTasks.sort(function (a, b) {
        var info1 = Core__Option.getExn(targets.get(a.target));
        var info2 = Core__Option.getExn(targets.get(b.target));
        if (info1.maxMoney < info2.maxMoney) {
          return 1;
        } else if (info1.maxMoney > info2.maxMoney) {
          return -1;
        } else {
          return 0;
        }
      });
}

function runTaskExn(ns) {
  var weakenScriptRam = ns.fileExists(weakenScript, undefined) ? ns.getScriptRam(weakenScript, undefined) : PervasivesU.failwith("no weaken script");
  var growScriptRam = ns.fileExists(growScript, undefined) ? ns.getScriptRam(growScript, undefined) : PervasivesU.failwith("no grow script");
  var hackScriptRam = ns.fileExists(hackScript, undefined) ? ns.getScriptRam(hackScript, undefined) : PervasivesU.failwith("no hack script");
  var availableRam = new Map();
  servers.forEach(function (serverList) {
        serverList.forEach(function (server) {
              var ram = server.host === "home" ? Math.max(server.availableRam - 32.0, 0.0) : server.availableRam;
              availableRam.set(server.host, ram);
            });
      });
  var tasks = new Set(todoTasks);
  tasks.forEach(function (task) {
        var allThreads = {
          contents: 0
        };
        var runCores = function (coresList, _coresIndex, f) {
          while(true) {
            var coresIndex = _coresIndex;
            var cores = coresList[coresIndex];
            if (cores !== undefined) {
              if (f(Caml_option.valFromOption(cores))) {
                return ;
              }
              _coresIndex = coresIndex + 1 | 0;
              continue ;
            }
            ns.print("INFO: no servers to " + actionToString(task.action) + " server " + task.target);
            return ;
          };
        };
        var runServers = function (cores, _serverIndex, script, scriptRAM, getThreads) {
          while(true) {
            var serverIndex = _serverIndex;
            var serverList = servers.get(cores);
            if (serverList !== undefined) {
              var server = serverList[serverIndex];
              if (server === undefined) {
                return false;
              }
              var ram = Core__Option.getExn(availableRam.get(server.host));
              if (ram >= scriptRAM) {
                var t = getThreads(task.target, server.cores);
                if (t.TAG === "Ok") {
                  var threads = t._0 - allThreads.contents | 0;
                  var threads$1 = threads === 0 ? 1 : threads;
                  if (threads$1 > 0) {
                    var fullThreads = Js_math.floor_int(ram / scriptRAM);
                    var exec = (function(ram,server){
                    return function exec(threads) {
                      var e = Helpers.execScript(ns, server.host, script, threads, undefined, true, [task.target]);
                      if (e.TAG === "Ok") {
                        var match = e._0;
                        scripts.set(match[0], {
                              target: task.target
                            });
                        tasks.delete(task);
                        allThreads.contents = allThreads.contents + match[1] | 0;
                        availableRam.set(server.host, Math.max(ram - match[2], 0.0));
                        return true;
                      }
                      ns.print("ERROR: failed to exec script " + script + " on server " + server.host, e._0);
                      return false;
                    }
                    }(ram,server));
                    if (fullThreads >= threads$1) {
                      if (exec(threads$1)) {
                        return true;
                      }
                      _serverIndex = serverIndex + 1 | 0;
                      continue ;
                    }
                    exec(fullThreads);
                    _serverIndex = serverIndex + 1 | 0;
                    continue ;
                  }
                  ns.print("INFO: threads " + threads$1.toString() + " is less than 1");
                  return true;
                }
                ns.print("ERROR: ", t._0);
                _serverIndex = serverIndex + 1 | 0;
                continue ;
              }
              _serverIndex = serverIndex + 1 | 0;
              continue ;
            }
            ns.print("ERROR: no cores " + cores.toString() + " in servers");
            return false;
          };
        };
        var match = task.action;
        switch (match) {
          case "Weaken" :
              ns.print("INFO: start weaken server " + task.target);
              return runCores(coresNum, 0, (function (cores) {
                            return runServers(cores, 0, weakenScript, weakenScriptRam, (function (host, cores) {
                                          return Server.weakenThreads(ns, host, cores, undefined);
                                        }));
                          }));
          case "Grow" :
              ns.print("INFO: start to grow server " + task.target);
              return runCores(coresNum, 0, (function (cores) {
                            return runServers(cores, 0, growScript, growScriptRam, (function (host, cores) {
                                          return Server.growThreads(ns, host, cores);
                                        }));
                          }));
          case "Hack" :
              ns.print("INFO: start to hack server " + task.target);
              return runCores(coresNum.toReversed(), 0, (function (cores) {
                            return runServers(cores, 0, hackScript, hackScriptRam, (function (host, param) {
                                          return Server.hackThreads(ns, host, undefined);
                                        }));
                          }));
          
        }
      });
  Caml_splice_call.spliceObjApply(todoTasks, "splice", [
        0,
        todoTasks.length,
        Array.from(tasks.values())
      ]);
}

async function main(ns) {
  var match = Flags.getFlagsExn(ns, schema);
  var flags = match[0];
  if (flags.help) {
    ns.tprint("Hacks max money from servers.\n--includePurchasedServers : Includes purchased servers.\n--includeHome : Includes home server.");
    return ;
  }
  ns.disableLog("getHackingLevel");
  ns.disableLog("scan");
  while(true) {
    var allServers = Helpers.crawlServers(ns, !flags.includePurchasedServers, !flags.includeHome);
    clearServers();
    allServers.forEach(function (server) {
          Helpers.getRootAccess(ns, server);
          var info = ns.getServer(server);
          updateServers(info);
          updateTargets(ns, info);
        });
    sortServers();
    updateTasks(ns);
    sortTodoTasksExn();
    runTaskExn(ns);
    await ns.asleep(5000.0);
  };
}

function autocomplete(data, args) {
  if (!Flags.argsHasHelp(Flags.argsToStrings(args))) {
    Flags.schemaToFlagsExn(data.flags, schema);
  }
  return [];
}

var homeLeastFreeRAM = 32.0;

export {
  weakenScript ,
  growScript ,
  hackScript ,
  schema ,
  homeLeastFreeRAM ,
  coresNum ,
  servers ,
  targets ,
  scripts ,
  todoTasks ,
  actionToString ,
  clearServers ,
  updateServers ,
  sortServers ,
  updateTargets ,
  updateTasks ,
  sortTodoTasksExn ,
  runTaskExn ,
  main ,
  autocomplete ,
}
/* servers Not a pure module */
