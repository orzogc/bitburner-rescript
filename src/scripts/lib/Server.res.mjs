// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function weakenThreads(ns, target, cores, weakenSecurity) {
  var info = ns.getServer(target);
  var match = info.hackDifficulty;
  var match$1 = info.minDifficulty;
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "notHackableServer"
          };
  }
  if (match$1 === undefined) {
    return {
            TAG: "Error",
            _0: "notHackableServer"
          };
  }
  var toWeaken = Core__Option.getOr(weakenSecurity, match - match$1);
  if (toWeaken <= 0.0) {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
  var singleWeaken = ns.weakenAnalyze(1, cores);
  if (singleWeaken > 0.0) {
    return {
            TAG: "Ok",
            _0: Js_math.ceil_int((toWeaken + 0.001) / singleWeaken)
          };
  } else {
    return {
            TAG: "Error",
            _0: "calculationFailure"
          };
  }
}

function growThreads(ns, target, cores) {
  var info = ns.getServer(target);
  var match = info.moneyAvailable;
  var match$1 = info.moneyMax;
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "notHackableServer"
          };
  }
  if (match$1 === undefined) {
    return {
            TAG: "Error",
            _0: "notHackableServer"
          };
  }
  var toGrow = match$1 / match;
  if (toGrow <= 1.0) {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
  var threads = ns.growthAnalyze(target, toGrow + 0.001, cores);
  if (threads > 0.0) {
    return {
            TAG: "Ok",
            _0: Js_math.ceil_int(threads)
          };
  } else {
    return {
            TAG: "Error",
            _0: "calculationFailure"
          };
  }
}

function hackThreads(ns, target, hackMoney) {
  var info = ns.getServer(target);
  var money = info.moneyAvailable;
  if (money === undefined) {
    return {
            TAG: "Error",
            _0: "notHackableServer"
          };
  }
  var toHack = Core__Option.getOr(hackMoney, money * 0.5);
  if (!(toHack >= 0.0 && toHack <= money)) {
    return {
            TAG: "Error",
            _0: "calculationFailure"
          };
  }
  var threads = ns.hackAnalyzeThreads(target, toHack);
  if (threads >= 0.0) {
    return {
            TAG: "Ok",
            _0: Js_math.ceil_int(threads)
          };
  } else {
    return {
            TAG: "Error",
            _0: "calculationFailure"
          };
  }
}

export {
  weakenThreads ,
  growThreads ,
  hackThreads ,
}
/* No side effect */
